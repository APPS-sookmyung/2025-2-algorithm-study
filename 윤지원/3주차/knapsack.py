"""
n개의 물건과 배낭이 있을 때, 각 물건에는 가치와 무게가 존재한다. 또한 각 물건은 1개씩만 있다.  이러한 조건일 때, 배낭의 최대 용량을 초과하지 않으면서 배낭에 담을 수 있는 최대 가치의 합을 찾는 문제다. 

### DP로 해결:

- 담는다, 담지 않는다 를 첫 번째 물건부터 시작해서 갈라지는 모든 경우의 수에 따라  그려본다.
- 문제를 반복하는 형식으로 쪼개 본다. 예를 들어 총 6kg를 담을 수 있는 가방에 이미 무게를 넣어 3kg이 남았을 때,  최대 3kg을 담을 수 있는 또 다른  배낭 문제를 생성하는 것이다.
- 위처럼 똑같은 로직을 반복할 때, 변하는 것은
    1. 배낭의 최대 무게
    2. 담을 수 있는 봉투의 개수 및 종류
- 따라서 2차원 배열을 사용하여 각 경우의 수에 따른 답을 따로 저장해줘야 한다.
- 최대이익[i][w] = 최대무게가 w인 가방에서 i번째 물건까지 판단했을 때의 최대 가치
    - 경우 1: 물건의 무게가 w를 초과할 때- 이 물건은 배낭에 넣을 수 없으므로 최대 가치는 이전의 최대 가치인 k번째로 유지 + 넣지 않았으므로 배낭 무게 w에는 아무런 변화 X . 따라서 dp[k+1][w]=dp[k][w] ( 기존 최대 가치)
    - 경우 2: 물건의 무게가 w를 초과하지 않을 때-
        - 넣지 않는다. dp[k+1][w]=dp[k][w]
        - 넣는다.  배낭 안에 해당 물건을 넣을 충분한 무게가 존재한다는 소리. 그런데 만약 충분한 공간(무게) 가 없다면 안에 있는 물건을 빼고 해당 물건을 넣어야 한다.

---

물건 k의 무게 > w(무게) : dp[k][w] = dp[k-1][w]

물건 k의 무게 ≤ w : dp[k][w]=max(dp[k-1][w], k의 가치+ dp[k-1][w-k 무게]) max(넣지 않는다, 넣는다)
"""
N,K=map(int,input().split())
wv=[]
for _ in range(N):
    wv.append(tuple(map(int,input().split())))

values=[[0]*(K+1) for p in range(N+1)]
for n in range(N):
    w,v=wv[n]
    for k in range(1,K+1):
        if w>k:
            values[n][k]=values[n-1][k]
        elif w<=k:
            values[n][k]=max(values[n-1][k-w]+v,values[n-1][k])

print(values[n][k])
